type M4 = [f32; 16];


pub fn mult(b: M4, a: M4) -> M4 {
    [
        a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12],
        a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13],
        a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14],
        a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15],
        a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12],
        a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13],
        a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14],
        a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15],
        a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12],
        a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13],
        a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14],
        a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15],
        a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12],
        a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13],
        a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14],
        a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15]
    ]
}



pub fn projection(aspect_ratio: f32, z_near: f32, z_far: f32) -> M4 {

    let r = 1.0 / (z_far - z_near);

    [
      1.0 / aspect_ratio, 0.0, 0.0, 0.0,
      0.0, -1.0, 0.0, 0.0,
      0.0, 0.0, (z_near + z_far) * r, -1.0,
      0.0, 0.0,  z_near * z_far * r * 2.0, 0.0
    ]
}


//pub fn rot(a: f32)-> M4{
//   let sin = a.sin();
//   let cos = a.cos();
//   [
//        cos, sin, 0.0, 0.0,
//       -sin, cos, 0.0, 0.0, 
//        0.0, 0.0, 1.0, 0.0,
//        0.0, 0.0, 0.0, 1.0
//    ]
//
//
//} 
//
//pub fn translation(x: f32, y: f32, z: f32) -> M4 {
//    let mut result = identity();
//
//    result[12] = x;
//    result[13] = y;
//    result[14] = z;
//
//    result
//}
